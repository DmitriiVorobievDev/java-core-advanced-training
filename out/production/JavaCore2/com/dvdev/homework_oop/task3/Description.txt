Задача:

Создать иерархию классов, описывающих геометрические фигуры на плоскости.

- Можно пользоваться результатами предыдущего ДЗ.
- В иерархии должно быть не менее 10 классов/интерфейсов и хотя бы 2 уровня
    вложенности.
- Продемонстрировать переопределение методов в иерархии.
- Продемонстрировать добавление собственных методов в классах-наследниках
    (можно с помощью интерфейсов).

Например, расчёт диагонали в прямоугольнике, расчёт высоты в треугольнике.

- При разработке иерархии держать в уме принцип инкапсуляции, выбирать
    корректные имена классов и методов, пользоваться преимуществами
    полиморфизма.
- Отдавайте предпочтение интерфейсам, а не абстрактным классам.
- При переопределении методов обязательно использовать аннотацию @Override
- Не создавать лишних классов в системе (полностью дублирующих или
    не содержащих назначения)
- Каждый класс должен выполнять своё назначение.

- Создать общие методы:
1. Рассчитывающий площадь фигуры.
2. Принимающий в качестве параметра фигуру и определяющий, равны ли
    площади текущей и полученной фигуры.

- Создать класс ShapeUtils со статическими методами:
1. Определяющим, является ли фигура прямоугольником.
2. Определяющим, является ли фигура треугольником.

- Для каждого неабстрактного класса переопределить метод toString()
    класса для представления информации о классах в строковой форме.


Task:

Create a hierarchy of classes that describe geometric shapes on a plane.

- You can use the results of the previous DZ.
- There must be at least 10 classes/interfaces and at least 2 levels in
    the hierarchy nesting.
- Demonstrate overriding methods in a hierarchy.
- Demonstrate adding your own methods to derived classes
     (It is possible with the help of interfaces).

For example, calculating the diagonal in a rectangle, calculating
    the height in a triangle.

- When developing a hierarchy, keep in mind the principle of encapsulation,
    choose correct class and method names, enjoy the benefits polymorphism.
- Favor interfaces over abstract classes.
- When overriding methods, be sure to use the @Override annotation
- Do not create unnecessary classes in the system
    (completely duplicating or not containing assignment)
- Each class must fulfill its purpose.

- Create common methods:
1. Calculating the area of a figure.
2. Taking a figure as a parameter and determining whether they are equal
     the area of the current and the resulting figure.

- Create class ShapeUtils with static methods:
1. Determining whether the figure is a rectangle.
2. Determining whether the figure is a triangle.

- For each non-abstract class, override the toString() method
     class to represent class information in string form.